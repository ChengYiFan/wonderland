## 模块模式
我们可以使用函数和闭包来构造模块。模块是一个提供接口却隐藏状态与实现的函数或对象。通过使用函数产生模块，可以完全摒弃全局变量的使用，从而缓解这个JavaScript的最为糟糕的特性之一所带来的影响。

模块模式利用函数作用域和闭包来创建被绑定对象与私有成员的关联。
模块模式的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可访问到的地方。

使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有效。

## ES6和CommonJS模块有什么区别
CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。（也就是说，cmmonjs模块输出后被改变，其他引用模块不会改变，而ES6模块会改）
CommonJS模块是运行时加载，ES6模块是编译时输出接口。（之所以webpack的tree-shaking只能作用于ES6模块，就是因为ES6模块在编译时就能确定依赖）

## 具体说明：
### 第一个区别
CommonJS模块输出的是值的拷贝，即：一旦输出一个值，模块内部的变化就影响不到这个值

ES6模块的运行基准值与CommonJS不一样，JS引擎对脚本静态分析的时候，遇到模块记载命令import，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。ES6模块是动态引用，并且不会缓存值，模块里面的那个变量绑定其所在的模块。

ES6中输入的模块变量，只是一个‘符号连接’，变量是只读的，对他重新赋值会报错。

export通过接口，输出的是同一个值，不同的脚本加载这个接口，得到的都是同样的实例。

### 第二个区别
是因为CommonJS加载的是一个对象（module.exports属性），该对象只有在脚本运行完才会生成，而ES6模块不是对象，他的对外接口是一种静态定义，在代码静态解析阶段就会完成